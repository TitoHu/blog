# 路由变更页面不刷新

## 背景
有`A`，`B`和`C`三个页面，通过`A`页面可以跳转到`B`页面，`B`页面可以跳转到`C`页面，同时`B`页面是一个可以切换tab的页面，tab有`x`，`y`和`z`三个，`B`页面打开时默认展示`x`tab，tab之间的切换不会切换链接。在用户实际使用的时候，会有以下几种情况：
1. `A`->`Bx`->`C`
2. `A`->`Bx`->`Bz`->`C`

当返回的时候，分别是以下两种情况：
1. `C`->`Bx`->`A`
2. `C`->`Bx`->`A`

第一种情况的交互是正常的，但是第二种情况的交互就会有一些不太友好，用户可能希望返回到`Bz`，但是直接返回到了`Bx`，在`Bx`下还要多一次操作才能切换到`Bz`。此时我们希望在第二种情况下返回应该是`C`->`Bz`->`A`这样的呈现方式，那么如何才能实现这样的功能呢？

## 思路
浏览器会记录浏览器tab的访问记录，作为历史记录，类似于栈的方式存储。当访问一个链接的时候，就会将这个链接压入栈中，当链接变化的时候，会把新的链接压入栈中，同时页面显示新链接的内容。当返回的时候，就会将历史记录中最后记录的取出，做出栈操作，然后显示历史记录栈中最后记录的链接内容。所以，我们要修改页面返回时候的显示顺序，就要在历史记录上面做一些操作。
在第二种情况中，如果我们想要最终返回的顺序是`C`->`Bz`->`A`，那么在最终显示C页面内容的时候，历史记录中链接存放的情况应该是`栈底`->`A`->`Bz`->`C`。这样在`C`页面返回的时候，就能够按照设想的顺序返回了。同时，由于`B`页面默认展示`x`tab，所以还要对`B`页面进行修改，使得`B`页面能够默认显示`z`tab。
在默认的情况下，`Bx`->`Bz`的时候，由于不会切换链接，只是页面内的变化，所以并不会将`Bz`记录在历史记录中，同时进入`B`页面的时候，会默认的将`Bx`记录在历史记录中。那么想要做成我们想要的历史记录顺序，就需要在`B`页面切换tab的时候，替换历史记录中记录的B的链接。
整理一下上面的思路发现，我们想要最终解决问题，就要解决以下这两个关键点：
1. 能够控制`B`页面默认展示不同的tab。
2. `B`页面切换tab的时候，替换历史记录。

## 解决方案
#### 控制`B`页面默认展示的tab
控制`B`页面默认展示的tab很简单，在页面`B`的链接中添加条件来控制页面默认展示的tab。

#### `B`页面切换tab的时候，替换历史记录
当页面链接切换的时候，就会将链接记录到历史记录中，所以切换tab的时候就需要改变链接。通过`window.location.replace(url)`可以替换当前的历史记录，同时改变页面的链接，就能够解决这个问题。但是这个方法在替换了链接的时候，页面也会随着刷新。对于页面`B`来讲，只是简简单单的页面内的tab切换，如果要做成刷新页面的话，就会使用户的体验变得很差。那么有没有一种方法可以既替换历史记录，又改变链接，同时不会刷新页面？
浏览器中有一个方法可以满足上述的内容，就是`history.replaceState(state, title, url)`参数`state`是链接相关的状态对象，`title`是标题，`url`是链接。通过上述的方法，就能在不刷新页面的情况下替换历史记录。但是由于这个API只有部分浏览器支持，所以在使用的时候需要先判断该API是否能够使用：
```javascript
if (window.history && window.history.replaceState) {
  // do something here
}
```

## 总结
所以，对于本次的这个问题，主要有以下几点，一是使得`B`页面的链接能够控制`B`页面默认显示的tab，二是在`B`页面中切换tab的时候使用`history.replaceState(state, title, url)`的方法，三是在使用方法前判断方法是否能在执行环境中使用。